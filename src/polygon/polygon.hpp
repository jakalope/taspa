/* 
 * Copyright 2009, 2010, Jake Askeland, jake(dot)askeland(at)gmail(dot)com
 * 
 *  * This program is free software: you can redistribute it and/or modify
 *     it under the terms of the GNU General Public License as published by
 *     the Free Software Foundation, either version 3 of the License, or
 *     (at your option) any later version.
 * 
 *     This program is distributed in the hope that it will be useful,
 *     but WITHOUT ANY WARRANTY; without even the implied warranty of
 *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *     GNU General Public License for more details.
 * 
 *     You should have received a copy of the GNU General Public License
 *     along with this program.  If not, see <http://www.gnu.org/licenses/>.
 * 
 *  * This file is part of Topological all shortest paths automatique' (TASPA).
 * 
 *     TASPA is free software: you can redistribute it and/or modify
 *     it under the terms of the GNU General Public License as published by
 *     the Free Software Foundation, either version 3 of the License, or
 *     (at your option) any later version.
 * 
 *     TASPA is distributed in the hope that it will be useful,
 *     but WITHOUT ANY WARRANTY; without even the implied warranty of
 *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *     GNU General Public License for more details.
 * 
 *     You should have received a copy of the GNU General Public License
 *     along with TASPA.  If not, see <http://www.gnu.org/licenses/>.
 */

#ifndef POLYGON_HPP
#define POLYGON_HPP

#include <vector>
#include <stdexcept>

#include "../location/location.hpp"
#include "AdjacencyMatrix.h"
#include "../exception/catch_all_exception.hpp"

////////////////////////////////////////////////////////////////////////////////
/** A collection of vertices whose interconnecting line segments do not
	intersect one another -- except at their endpoints. Initializing a polygon
	object requires a temporary copy of the set of all vertices V in the map.
	The largest possible convex subset of V, denoted here as V*, is stored as
	the polygon's vertices. Every entry in V which is also in V* will have its
	edges removed for all other entries in V that are now a part of or
	obstructed by the edges in the polygon. The set of edges in the polygon E*
	is a subset of all potential edges in the map, E.

	For example, let four vertices ($v_1$, $v_2$, $v_3$, $v_4$, in
	this order, counter-clockwise) make up V* and let some vertex
	$v_x$, not in V*, be adjacent to (visible from) $v_2$. Now consider
	that the edge between $v_1$ and $v_3$, denoted $e_13 \in $ E*, generated by
	the new polygon from V*, obfuscates the adjacency of $v_2$ and $v_x$.
	The nodes stored in $v_2$ and $v_x$, which store their adjacency, are
	altered to reflect the adjacency is no longer available.

	Let the set of potential edges between vertices of V* to all
	adjacent nodes {\em not in V*} be *E*. Then a search through *E*,
	checking for geometric (location-wise) intersections with edges
	in E* will be the mechanism used to check for the above mentioned
	invalidated adjacencies.

	Further, there are three adjacencies in each vertex in an open convex
	quadrilateral but only two adjacencies per vertex are allowed in a polygon.
	Because of this, the diagonals \{ ($v_1$, $v_3$), ($v_2$, $v_4$),
	($v_3$, $v_1$), ($v_4$, $v_2$) \} must all be updated to show their
	unaviliability.

	In other words, we need to search through all the new edges in the
	polygon, looking for intersections with lines of sight with vertices
	in the polygon and vertices not in the polygon. These intersections
	represent invalid potential edges for new polygons. Without the
	invalidation, we would wind up with polygons overlapping one another.
	While this would be useful to enumerate all possible polygons in a map,
	it is undesireable for our purposes. Also, when a polygon is created,
	the lines of sight between vertices in the polygon which are not making
	up edges of the polygon must be invalidated for the same reason.

	@version 0.1.0 Build 0
	@author J. Askeland
	@memo
*/
class polygon : public location::Vector {
	
	private:

	protected:

	/////////////////////////////////////////////////////
	/** @name Protected Members **/
	//@{
	
	inline int isLeft( location P0, location P1, location P2 );
	
	//@}
	
		
	public:

    typedef std::vector<polygon> Vector;
    typedef Vector::iterator VectorIter;
    typedef Vector::const_iterator ConstVectorIter;

	/////////////////////////////////////////////////////
	/** @name Constructors **/
	//@{

	/** Creates a polygon with no vertices. See the methods 
		#GeneratePolygon# and #AddVertex# in order to add vertices 
		automatically or manually, respectively.
		@memo */
	polygon () { }

	/** Calls #GeneratePolygon#, passing allVertices to it by non-const 
		refernce. Using this constructor continuously until no vertices 
		are left in allVertices will fill the available region(s) with 
		convex polygons.

		@param  Graph Set of all vertices on the graph.
		@precondition Graph has at least three usable #PolyVertex#'s.
		@postcondition *this will store a maximal subset of the #PolyVertex#s 
			in #Graph# such that the subset forms a polygon.
		@memo */
	polygon (AdjacencyMatrix& adj);

	//@}


	/////////////////////////////////////////////////////
	/** @name Operators **/
	//@{

	/////////////////////////////////////////////////////
	/** @name Public Members **/
	//@{

	/** Determines whether loc is inside this polygon, using a winding 
		number method.

		@param  location object with elements (x,y), describing a point 
		@return true if loc is inside this polygon
		@memo 
	*/
	/*  Winding number method is defined in polyomino_stats.h under:
		int wn_PnPoly( location P, location* V, int n );
	*/
	bool Contains( location pt );

	/** Gets this polygon's nearest vertex from the given location. 
		Checks the distance between #loc# and each vertex in this polygon 
		to determine which vertex is closest, then returns that vertex. 

		@param  loc location object with elements (x,y), describing a point 
		@return vertex object with information about other visible vertices 
		@memo */
	location NearestVertex (const location& loc);

	/** Generates a polygon using the greatest number of vertices from 
		allVertices, removing any vertices that are fully connected. 
		Fully connected vertices are vertices who can no longer see other 
		vertices they aren't already connected to. Typically this occurs 
		when a vertex has been used in one or two polygons and the only 
		vertices not directly connected to it are used in the same polygon. 

		Using this method continuously until no vertices are left in 
		allVertices will fill the available region(s) with convex polygons.
		@memo 
	*/
	void GeneratePolygon(AdjacencyMatrix&);
	
	location GetFirst() { return *begin(); }
	location GetLast() { return *rbegin(); }
	
	//@}
};

void GeneratePolygons (std::vector<polygon>& polyList, 
		std::vector<polygon>& unusedPolyList, location::Set& sharedSet, 
		location::Set& U, AdjacencyMatrix& M, bool verbose, 
		std::ostream& outStrm);

#endif

