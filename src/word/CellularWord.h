#ifndef CELLULAR_WORD_H
#define CELLULAR_WORD_H

#include <string>
#include "PotentialLine.h"

class SimpleLine : public std::pair<int,int>
{
    public:
    SimpleLine() {}
    SimpleLine(int f, int s) : std::pair<int,int>(f,s) { }
    int getIndex() const { return first; }
    int getLength() const { return second; }
    int& Index() { return first; }
    int& length() { return second; }
};


class Line : public std::pair<int,int>
{
    bool isLine;
    int majority_count;
    
    public:
    
    Line() : std::pair<int,int>(0,0), isLine(false) { }
        
    Line(Stair::Case& s) { 
        PotentialLine p(s); 
        p.ShortenUntilLinear(); 
        first = p.Index(); 
        second = p.length();
        isLine = p.IsLine();
        majority_count = p.MajorityCount();
    }
    
    int& Index() { return first; }
    int& length() { return second; }
    bool IsLine() { return isLine; }
    int MajorityCount() { return majority_count; }

    bool operator<(Line l)
    {
        if (first == l.first)
            return second < l.second;
        return (first < l.first);
    }
};

class CellularWord : public std::string
{
    private:
    
    typedef std::list<Line>::iterator LineIter;
    typedef Stair::Case::iterator StaircaseIter;
    typedef std::list<SimpleLine> SimpleLineList;
    typedef std::set<SimpleLine> SimpleLineSet;
    typedef SimpleLineSet::iterator SLineIter;
    typedef SimpleLineList::iterator LLineIter;

    void AddToLineSet
        (LLineIter A_begin, LLineIter A_end, 
         LLineIter B_begin, LLineIter B_end, SimpleLineSet& C);

//    void ReplaceLinear(Stair::Case& s, std::string& word);
    template<class Staircase_iteratorType>
    SimpleLine GetLongestLine
    (Staircase_iteratorType begin, Staircase_iteratorType end, std::string& word);

    void ReplaceIntermediates(const SimpleLine& p, char val, std::string& word);

    public:

    CellularWord(Stair::Case& cx, Stair::Case& xc, std::string& word);
};

template<class Staircase_iteratorType>
SimpleLine CellularWord::GetLongestLine
(Staircase_iteratorType begin, Staircase_iteratorType end, std::string& word)
{
    // For each vertex v:
        // Generate longest available line starting from v.
        // Replace all intermediate points with 's'.
    
//    Stair::Case B2 = B1;
//    std::list<SimpleLine> pre_S, S;
//    std::list<SimpleLine> pre_R, R;

    // B = { r_1, r_2, ..., r_n, s_1, s_2, ..., s_m } where 
    // each element r_i is adjacent to each element r_i-1 and r_i+1 and 
    // each element s_i is adjacent to each element s_i-1 and s_i+1.
    // 
    // Let R = { r_j in B : 
    //      IndexOf(s_i) < IndexOf(r_j) <= IndexOf(s_i+1)
    //      and IndexOf(s_i+1) < IndexOf(r_j+1)
    //      for all pairs i in 1,...,m and j in 1,...,n }
    //
    // Let S = { s_j in B : 
    //      IndexOf(r_i) < IndexOf(s_j) <= IndexOf(r_i+1)
    //      and IndexOf(r_i+1) < IndexOf(s_j+1)
    //      for all pairs i in 1,...,n and j in 1,...,m }
    //
    // In order words: R is the set of all lines in B, generated by
    // front-removal (see Loop 2, below), such that the following is true...
    //      For all r in R, there exists some s in S such that:
    //          -the beginning of r falls after the beginning of s,
    //          -the beginning of r falls before or at the end of s,
    //          -the end or r falls after the end of s.
    // and S is defined in the same manner with respect to R, using back-
    // removal (see Loop 1, below).


    // Loop 1

    SimpleLine L1(0,0);
//    Staircase_iteratorType i = begin;
    int maxCount = 2;

//    while (i != end) 
//    {
        // Find the longest line beginning at the current
        // initial Stair.
        Stair::Case s;
        for (Staircase_iteratorType m = begin; m != end; m ++)
            s.push_back(*m);
        Line p(s);
        
        if (p.MajorityCount() > maxCount && p.IsLine()) {
            maxCount = p.MajorityCount();
            L1.first = p.Index(); L1.second = p.length();
            // p.second;
        }
//            S.push_back(SimpleLine(p.first,p.second));
//        i ++;
//        B1.pop_front();
//    }

    return L1;
//    SimpleLine L2;
//
//    // Loop 2
//    while (B2.front() != B2.back()) 
//    {
//        // Find the longest line beginning at the current
//        // initial Stair.
//        Line p(B2);
//        int maxCount = 2;
//        
//        if (p.MajorityCount() > maxCount && p.IsLine()) {
//            maxCount = p.MajorityCount();
//            L2.first = p.first; L2.second = p.second;
//        }
//
////            R.push_back(SimpleLine(p.first,p.second));
//
//        B2.pop_back();
//    }
}

#endif
